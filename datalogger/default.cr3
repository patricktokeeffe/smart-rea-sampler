''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Long-term canister-based trace gas flux measurement system
' using the Relaxed Eddy Accumulation (REA) technique
'
' Laboratory for Atmospheric Research
' Department of Civil & Environmental Engineering
' Washington State University
'
' Licensed under the terms of The MIT License
'
' Contact:  Patrick O'Keeffe <pokeeffe@wsu.edu>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'manually update this constant with results of `git describe` prior to
'deployment but do not check-in file with any value other than empty string
Const VERSION = ""

'========================= DEFAULT SETTINGS =================================
ConstTable
  Const UTC_OFFSET = -8 'Pacific Standard Time
EndConstTable


'============================== WIRING ======================================
Const SONIC_COM = Com4 'C7/C8
Const GPS_COM = Com3   'C5/C6

Const HMP_T_DF = 8
Const HMP_RH_DF = 9

Const CTRL_VLV_UP = 1 'C1
Const CTRL_VLV_DN = 2 'C2
'reserved              C3
Const CTRL_PUMPS  = 4 'C4

Const P_CAN_UP_SE = 25
Const P_CAN_DN_SE = 26
Const P_PMP_UP_SE = 27
Const P_PMP_DN_SE = 28
Const P_BARO_SE   = 1

Const SW12_CAN_P = 9  'SW12-1
Const SW12_PMP_P = 10 'SW12-2


'============================ CONSTANTS =====================================
Const MBAR_PER_PSI = 68.947573 'mbar/psia
Const MBAR_PER_INHG = 33.864882 'mbar/inHg
Const PI = 3.14159

Const INTEG = 250     'analog integration time
Const FAST_INTV = 100 'milliseconds, scan freq.
Const FAST_BUFF = 10 
Const SLOW_INTV = 1   'seconds, scan freq.
Const SLOW_BUFF = 5
Const STATS_INTV = 30 'minutes, stats output
Const STOPFULL = 1    'stop recording when tables are full

Const SONIC_RECLEN = 34 'characters per record
Const SONIC_BAUD = 38400
Const SONIC_FORMAT = 3 '8/N/1 @ RS-232 voltages without PakBus pass-thru
Const SONIC_BUFF = SONIC_RECLEN*2 + 1
Const SONIC_VAZ = 0 'device-specific value, offset of device azimuth

Const HMP_T_OFF   = -80
Const HMP_T_MULT  = (60 - HMP_T_OFF)/1000 '-80 to +60 *C over 1V
Const HMP_RH_OFF  = 0
Const HMP_RH_MULT = (100 - HMP_RH_OFF)/1000 '0-100% over 1V

Const P_CAN_UP_OFF = MBAR_PER_PSI*0
Const P_CAN_UP_MLT = MBAR_PER_PSI*(30-P_CAN_UP_OFF)/5000 '0-30 psia over 5Vdc
Const P_CAN_DN_OFF = P_CAN_UP_OFF
Const P_CAN_DN_MLT = P_CAN_UP_MLT

Const P_PMP_UP_OFF = MBAR_PER_PSI*0
Const P_PMP_UP_MLT = MBAR_PER_PSI*(15-P_PMP_UP_OFF)/5000 '0-15 psia over 5Vdc
Const P_PMP_DN_OFF = P_PMP_UP_OFF
Const P_PMP_DN_MLT = P_PMP_UP_MLT

Const P_BARO_OFF = MBAR_PER_INHG*16
Const P_BARO_MLT = MBAR_PER_INHG*(32-P_BARO_OFF)/5000 '16-32 inHg over 5Vdc

Const GPS_INTV = 15 'seconds, scan freq.
Const GPS_MAX_DIFF = 25 'msec, clock tolerance
Const GPS_MED_NUM = 86400/GPS_INTV 'max # of values included in median calc


'============================= VARIABLES ====================================
Dim sonic_bytes
Dim sonic_record As String * SONIC_RECLEN
Public sonic(5)
Alias sonic(1) = sonic_Ux
Alias sonic(2) = sonic_Uy
Alias sonic(3) = sonic_Uz
Alias sonic(4) = sonic_Ts
Alias sonic(5) = sonic_diag
Units sonic = m/s
Units sonic_Ts = degC
Units sonic_diag = arb

Public disable_sonic As Boolean
Public sonic_azimuth = {0}

Public hmp(3)
Alias hmp(1) = hmp_T
Alias hmp(2) = hmp_RH
Alias hmp(3) = hmp_e
Units hmp_T = degC
Units hmp_RH = %
Units hmp_e = kPa

Public pressure(5)
Alias pressure(1) = press_can_UP
Alias pressure(2) = press_can_DN
Alias pressure(3) = press_pump_UP
Alias pressure(4) = press_pump_DN
Alias pressure(5) = press_baro
Units pressure = mbar

Dim nmea_str(2) As String * 90
Public gps16x(15)
Alias gps16x(1)  = lat_deg        '(+)=North, (-)=South
Alias gps16x(2)  = lat_min
Alias gps16x(3)  = long_deg       '(+)=East, (-)=West
Alias gps16x(4)  = long_min
Alias gps16x(5)  = speed
Alias gps16x(6)  = course
Alias gps16x(7)  = mag_var        '(+)=East, (-)=West
Alias gps16x(8)  = fix_quality
Alias gps16x(9)  = num_sat
Alias gps16x(10) = altitude
Alias gps16x(11) = since_pps
Alias gps16x(12) = since_gprmc
Alias gps16x(13) = gps_ready
Alias gps16x(14) = max_clock_change
Alias gps16x(15) = num_clock_change
Units speed = m/s
Units course = degEofN
Units mag_var = degEofN
Units fix_quality = unitless
Units num_sat = count
Units altitude = m
Units since_pps = ms
Units since_gprmc = s
Units max_clock_change = ms
Units num_clock_change = occurrences

'-------------------------- PROCESSING -------------------------------------
Public cov_sonic(1,4) '= [ [Ts, Ux, Uy, Uz] ]

Public work_out(20)
Alias work_out(1)  = Ux_Avg '4x Average()
Alias work_out(2)  = Uy_Avg
Alias work_out(3)  = Uz_Avg
Alias work_out(4)  = Ts_Avg
Alias work_out(5)  = Ts_Std 'Covariance(), 10 vals
Alias work_out(6)  = cov_Ts_Ux
Alias work_out(7)  = cov_Ts_Uy
Alias work_out(8)  = cov_Ts_Uz
Alias work_out(9)  = Ux_Std
Alias work_out(10) = cov_Ux_Uy
Alias work_out(11) = cov_Ux_Uz
Alias work_out(12) = Uy_Std
Alias work_out(13) = cov_Uy_Uz
Alias work_out(14) = Uz_Std
Alias work_out(15) = sonic_WS_sclr_Avg 'WindVector, 4 vals
Alias work_out(16) = sonic_WS_rslt_Avg
Alias work_out(17) = sonic_WD_rslt_Avg
Alias work_out(18) = sonic_WD_csi_Std
Alias work_out(19) = hmp_T_Avg '2x Average()
Alias work_out(20) = hmp_e_Avg
Units Ux_Avg = m/s
Units Uy_Avg = m/s
Units Uz_Avg = m/s
Units Ts_Avg = degC
Units Ts_Std = degC
Units Uz_Std = m/s
Units sonic_WS_sclr_Avg = m/s
Units sonic_WS_rslt_Avg = m/s
Units sonic_WD_rslt_Avg = degEofTN
Units sonic_WD_csi_Std = degrees
Units hmp_T_Avg = degC
Units hmp_e_Avg = kPa

Public derived(2)
Alias derived(1) = hmp_e_sat_Avg
Alias derived(2) = hmp_RH_Avg
Units hmp_e_sat_Avg = kPa
Units hmp_RH_Avg = %

Public Uz_rot 'real-time coordinate-rotated
Units Uz_rot = m/s

Dim sqrt_UV
Dim sqrt_UVW
Public rot_angles(6)
Alias rot_angles(1) = CE
Alias rot_angles(2) = SE
Alias rot_angles(3) = CT
Alias rot_angles(4) = ST
Alias rot_angles(5) = eta
Alias rot_angles(6) = theta
Units eta = degrees
Units theta = degrees

Public rotated(4) 'stream-wise coordinates
Alias rotated(1) = U_Avg
Alias rotated(2) = V_Avg
Alias rotated(3) = W_Avg
Alias rotated(4) = W_Std
Units rotated = m/s

'----------------------------- OPERATION -----------------------------------
Public deadband
Dim neg_deadband
Units deadband = m/s

Public vlv_up_ON As Boolean
Public vlv_dn_ON As Boolean

Dim just_had_slow_scan As Boolean
Dim inbetween_slow_scan As Boolean


'============================ DATA TABLES ===================================
DataTable(ts_fast,True,1000) 'FIXME - # records
  DataInterval(0,FAST_INTV,msec,10)
  CardOut(STOPFULL,10*60*60*4) '4 hours, FIXME
  
  Sample(1,sonic_Ux,IEEE4) 'TODO - FP2? only reported to two decimal places
  Sample(1,sonic_Uy,IEEE4)
  Sample(1,sonic_Uz,IEEE4)
  Sample(1,sonic_Ts,IEEE4)
  Sample(1,sonic_diag,IEEE4)
EndTable

DataTable(ts_slow,True,1000) 'FIXME - # records
  DataInterval(0,SLOW_INTV,sec,10)
  CardOut(STOPFULL,1000) 'FIXME - # records
  
  Sample(1,hmp_T,IEEE4)
  Sample(1,hmp_RH,IEEE4)
  Sample(1,press_can_UP,IEEE4)
  Sample(1,press_can_DN,IEEE4)
  Sample(1,press_pump_UP,IEEE4)
  Sample(1,press_pump_DN,IEEE4)
  Sample(1,press_baro,IEEE4)
EndTable

DataTable(work,True,2)
  DataInterval(0,STATS_INTV,Min,1)
  Average(1,sonic_Ux,IEEE4,disable_sonic)
  Average(1,sonic_Uy,IEEE4,disable_sonic)
  Average(1,sonic_Uz,IEEE4,disable_sonic)
  Average(1,sonic_Ts,IEEE4,disable_sonic)
  Covariance(4,cov_sonic(1,1),IEEE4,disable_sonic,10)
  WindVector(1,-1*sonic_Uy,sonic_Ux,IEEE4,disable_sonic,0,1,2)
  Average(1,hmp_T,IEEE4,(inbetween_slow_scan OR hmp_T=NAN))
  Average(1,hmp_e,IEEE4,(inbetween_slow_scan OR hmp_e=NAN))
EndTable

DataTable(stats,True,1000) 'FIXME - # records
  DataInterval(0,STATS_INTV,Min,10)
  CardOut(STOPFULL,1000) 'FIXME - # records

  Average(1,sonic_Ts,FP2,disable_sonic or sonic_Ts=NAN)
  StdDev (1,sonic_Ts,FP2,disable_sonic)
  StdDev (1,sonic_Uz,FP2,disable_sonic) 'TODO ? replace this with Uz_Std?
  Sample (1,sonic_WS_sclr_Avg,FP2)
  Sample (1,sonic_WS_rslt_Avg,FP2)
  Sample (1,sonic_WD_rslt_Avg,FP2)
  Sample (1,sonic_WD_csi_Std,FP2)
  
  Sample (1,hmp_T_Avg,FP2)
  Sample (1,hmp_RH_Avg,FP2)
  Sample (1,hmp_e_Avg,FP2)
  
  Average(1,press_can_UP,IEEE4,(inbetween_slow_scan OR press_can_UP=NAN))
  Average(1,press_can_DN,IEEE4,(inbetween_slow_scan OR press_can_DN=NAN))
  Average(1,press_pump_UP,IEEE4,(inbetween_slow_scan OR press_pump_UP=NAN))
  Average(1,press_pump_DN,IEEE4,(inbetween_slow_scan OR press_pump_DN=NAN))
  Average(1,press_baro,IEEE4,(inbetween_slow_scan OR press_baro=NAN))
  
  Sample(1,Uz_Std,IEEE4)
  Sample(1,W_Std,IEEE4)
  Sample(1,eta,IEEE4)
  Sample(1,theta,IEEE4)
EndTable

DataTable(gps_daily,TRUE,30)
  DataInterval (0,1,Day,10)
  CardOut(STOPFULL,150)
  Median(1,(lat_deg + lat_min/60),GPS_MED_NUM,IEEE4,(lat_deg=NAN OR lat_min=NAN))
    FieldNames("latitude_Med")
    Units latitude_Med = degN
  Median(1,(long_deg + long_min/60),GPS_MED_NUM,IEEE4,(long_deg=NAN OR long_min=NAN))
    FieldNames("longitude_Med")
    Units longitude_Med = degE
  Median(1,mag_var,GPS_MED_NUM,FP2,mag_var=NAN)
  Average(1,num_sat,FP2,num_sat=NAN)
  Median(1,altitude,GPS_MED_NUM,IEEE4,altitude=NAN)
  Average(1,altitude,FP2,altitude=NAN)
  Minimum(1,gps_ready,FP2,gps_ready=NAN,0)
  Sample(1,max_clock_change,UINT2)
  Sample(1,num_clock_change,UINT2)
EndTable


'============================= CUSTOM MENUS =================================
Const Yes = True
Const Cancel = False
Dim recompile As Boolean

DisplayMenu("LT REA DAQ", -1)
  SubMenu("Initial setup")
    MenuItem("Time zone", UTC_OFFSET)
      MenuPick(UTC_OFFSET,-8,-7,-6,-5,-4) 'FIXME: not valid outside USA
    MenuRecompile("Recompile?", recompile)
      MenuPick(Cancel,Yes)
  EndSubMenu
EndMenu


'============================= SUBROUTINES ==================================
Sub update_deadband() 'FIXME TODO
  deadband = 0.1
  neg_deadband = -1*deadband
EndSub

Sub reset_rotangles()
  Move(rot_angles(1),6,0,1)
  CT = 1.0
EndSub

Sub setup()
  update_deadband()
  reset_rotangles() 'TODO retain rotation angles across power cycles
  
  SerialOpen(SONIC_COM,SONIC_BAUD,SONIC_FORMAT,0,SONIC_BUFF)
  PortSet(SW12_CAN_P,True)
  PortSet(SW12_PMP_P,True)
EndSub

Public onoff

'============================== PROGRAM =====================================
BeginProg
  setup()
  
  Scan(FAST_INTV,msec,FAST_BUFF,0)
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
    If TimeIntoInterval(0,1,Min) Then
      onoff = NOT onoff
      PortSet(CTRL_PUMPS,onoff)
    EndIf
    ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

    SerialInRecord(SONIC_COM,sonic_record,0,SONIC_RECLEN,&h0D,sonic_bytes,11)
    SplitStr(sonic(1),sonic_record,0,5,0)
    disable_sonic = (sonic_diag > 0 OR sonic_diag=NAN OR sonic_Ts=NAN OR _
                                sonic_Ux=NAN OR sonic_Uy=NAN or sonic_Uz=NAN)
    Uz_rot = sonic_Uz*CT - sonic_Uz*ST*CE - sonic_Uy*ST*SE
    vlv_up_ON = False
    vlv_dn_ON = False
    If (False) Then 'TODO If (NOT is_running) Then
      'do nothing
    ElseIf (Uz_rot >= deadband) Then
      vlv_up_ON = True
    ElseIf (Uz_rot <= neg_deadband) Then
      vlv_dn_ON = True
    EndIf
    PortSet(CTRL_VLV_UP,vlv_up_ON) 'HINT use PortSet (measurment task) not
    PortSet(CTRL_VLV_DN,vlv_dn_ON) 'WriteIO (processing task = delayed)

    CallTable(ts_fast)
    CallTable(work)
    If (work.Output(1,1)) Then
      GetRecord(work_out(1),work,1)

      sqrt_UV = SQR(Ux_Avg^2 + Uy_Avg^2)
      sqrt_UVW = SQR(Ux_Avg^2 + Uy_Avg^2 + Uz_Avg^2)
      CE = Ux_Avg/sqrt_UV
      SE = Uy_Avg/sqrt_UV
      CT = sqrt_UV/sqrt_UVW
      ST = Uz_Avg/sqrt_UVW
      If (CE=NAN OR SE=NAN OR CT=NAN OR ST=NAN) Then
        reset_rotangles()
      Else
        eta = ATN2(SE,CE)*180/PI
        theta = ATN2(ST,CT)*180/PI
      EndIf
      U_Avg = Ux_Avg*CT*CE + Uy_Avg*CT*SE + Uz_Avg*ST
      V_Avg = Uy_Avg*CE - Ux_Avg*SE
      W_Avg = Uz_Avg*CT - Ux_Avg*ST*SE - Uy_Avg*ST*SE
      'HINT in following line *_Std values are still covariances
      W_Std = SQR(Uz_Std*CT*CT + Ux_Std*ST*ST*CE*CE + Uy_Std*ST*ST*SE*SE - 2*cov_Uy_Uz*CT*ST*SE + 2*cov_Ux_Uy*CE*ST*ST*SE)
      'now convert cov -> std
      Uz_Std = SQR(Uz_Std)
      Ts_Std = SQR(Ts_Std)
      
      update_deadband()

      If (sonic_WS_sclr_Avg = NAN AND sonic_WS_rslt_Avg = NAN) Then
        sonic_WD_rslt_Avg = NAN
        sonic_WD_csi_Std = NAN
      Else
        sonic_WD_rslt_Avg = (Round(sonic_WD_rslt_Avg,0)+sonic_azimuth) MOD 360
      EndIf
      
      SatVP(hmp_e_sat_Avg, hmp_T_Avg)
      hmp_RH_Avg = 100*hmp_e_Avg/hmp_e_sat_Avg
      'DewPoint(hmp_Tdew_Avg, hmp_T_Avg, hmp_RH_Avg) 'TODO ????
    EndIf
    CallTable(stats)
    
    inbetween_slow_scan = True
    If (just_had_slow_scan) Then
      just_had_slow_scan = False
      inbetween_slow_scan = False
    EndIf
  NextScan

  SlowSequence
  Scan(SLOW_INTV,sec,3,0)
    VoltDiff(hmp_T,1,mv1000,HMP_T_DF,True,0,INTEG,HMP_T_MULT,HMP_T_OFF)
    VoltDiff(hmp_RH,1,mv1000,HMP_RH_DF,True,0,INTEG,HMP_RH_MULT,HMP_RH_OFF)
    VaporPressure(hmp_e, hmp_T, hmp_RH)

    VoltSe(press_can_UP,1,mv5000,P_CAN_UP_SE,True,0,INTEG, P_CAN_UP_MLT,P_CAN_UP_OFF)
    VoltSe(press_can_DN,1,mv5000,P_CAN_DN_SE,True,0,INTEG, P_CAN_DN_MLT,P_CAN_DN_OFF)
    VoltSe(press_pump_UP,1,mv5000,P_PMP_UP_SE,True,0,INTEG, P_PMP_UP_MLT,P_PMP_UP_OFF)
    VoltSe(press_pump_DN,1,mv5000,P_PMP_DN_SE,True,0,INTEG, P_PMP_DN_MLT,P_PMP_DN_OFF)
    VoltSe(press_baro,1,mv5000,P_BARO_SE,True,0,INTEG, P_BARO_MLT,P_BARO_OFF)

    CallTable(ts_slow)
    just_had_slow_scan = True
  NextScan

  SlowSequence
  Scan(GPS_INTV,sec,1,0)
    GPS(gps16x(1),GPS_COM,UTC_OFFSET*3600,GPS_MAX_DIFF,nmea_str(1))
    CallTable(gps_daily)
  NextScan
EndProg

